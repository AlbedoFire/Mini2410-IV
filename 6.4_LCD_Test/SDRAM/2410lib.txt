; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\sdram\2410lib.o --asm_dir=.\SDRAM\ --list_dir=.\SDRAM\ --depend=.\sdram\2410lib.d --cpu=ARM920T --apcs=interwork -O3 --diag_suppress=9931 -I..\Common\Inc -I.\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Samsung -D__UVISION_VERSION=517 --omf_browse=.\sdram\2410lib.crf ..\common\src\2410lib.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  port_init PROC
;;;32     *********************************************************************************************/
;;;33     void port_init(void)
000000  e92d0030          PUSH     {r4,r5}
;;;34     {
;;;35         //CAUTION:Follow the configuration order for setting the ports. 
;;;36         // 1) setting control register (GPnCON)
;;;37         //    * (bitn) -- means this pin not use on circuit, and set as default function
;;;38         // 2) configure pull-up resistor (GPnUP)  
;;;39         // 3) setting value (GPnDAT)
;;;40     
;;;41         //32bit data bus configuration  
;;;42         //=== PORT A GROUP
;;;43         //Ports  : GPA22  GPA21  GPA20  GPA19  GPA18  GPA17  GPA16  GPA15  GPA14  GPA13  GPA12  
;;;44         //Signal : nFCE   GPA21  nFRE   nFWE   ALE    CLE    GPA16  nGCS4  nGCS3  nGCS2  nGCS1 
;;;45         //Setting: nFCE   Output nFRE   nFWE   ALE    CLE    Output nGCS4  nGCS3  nGCS2  nGCS1 
;;;46         //Binary : 1      *0      1,     1      1      1      *0,    1      1      1      1
;;;47         //----------------------------------------------------------------------------------------
;;;48         //Ports  : GPA11  GPA10   GPA9   GPA8   GPA7   GPA6   GPA5   GPA4   GPA3   GPA2   GPA1   GPA0
;;;49         //Signal : GPA11 ADDR25  ADDR24 ADDR23 ADDR22 ADDR21 ADDR20 ADDR19 ADDR18 ADDR17 ADDR16 ADDR0 
;;;50         //Binary : *0     1       1      1,     1      1      1      1,     1      1      1      1         
;;;51         rGPACON = 0x5fbfff;
;;;52     
;;;53         //===* PORT B GROUP
;;;54         //Ports  : GPB10  GPB9   GPB8   GPB7   GPB6   GPB5    GPB4    GPB3   GPB2   GPB1  GPB0
;;;55         //Signal : GPB10  GPB9   GPB8   GPB7   GPB6   DIS_OFF L3CLOCK L3DATA L3MODE PWM2  PWM1
;;;56         //Setting: Output Output Output Output Output Output  Output  Output Output TOUT1 TOUT0 
;;;57         //Binary : 01,    01     *01,   *01    *01,   01      01,     01     01,    10    10  
;;;58         rGPBCON = 0x155559;
;;;59         rGPBUP  = 0x7ff;      // The pull up function is disabled GPB[10:0]
000004  e59f2724          LDR      r2,|L1.1840|
000008  e59f4724          LDR      r4,|L1.1844|
00000c  e59f3724          LDR      r3,|L1.1848|
;;;60     
;;;61         //=== PORT C GROUP
;;;62         //Ports  : GPC15 GPC14 GPC13 GPC12 GPC11 GPC10 GPC9 GPC8 GPC7   GPC6   GPC5   GPC4 GPC3   GPC2  GPC1 GPC0
;;;63         //Signal : VD7   VD6   VD5   VD4   VD3   VD2   VD1  VD0  Output Output Output OUT   VFRAME VLINE VCLK LEND  
;;;64         //Binary : 10    10,   10    10,   10    10,   10   10,  *01    *01,   *01    01,  10     10,   10   10
;;;65         rGPCCON = 0xaaaa55aa;       
000010  e59fc724          LDR      r12,|L1.1852|
000014  e3a00456          MOV      r0,#0x56000000        ;51
;;;66         rGPCUP  = 0xffff;     // The pull up function is disabled GPC[15:0] 
000018  e1821282          ORR      r1,r2,r2,LSL #5
00001c  e5804000          STR      r4,[r0,#0]            ;51
;;;67     
;;;68         //=== PORT D GROUP
;;;69         //Ports  : GPD15 GPD14 GPD13 GPD12 GPD11 GPD10 GPD9 GPD8 GPD7 GPD6 GPD5 GPD4 GPD3 GPD2 GPD1 GPD0
;;;70         //Signal : VD23  VD22  VD21  VD20  VD19  VD18  VD17 VD16 VD15 VD14 VD13 VD12 VD11 VD10 VD9  VD8
;;;71         //Binary : 10    10,   10    10,   10    10,   10   10,  10   10,  10   10,  10   10,  10   10
;;;72         rGPDCON = 0xaaaaaaaa;       
000020  e28c4c55          ADD      r4,r12,#0x5500
000024  e5803010          STR      r3,[r0,#0x10]         ;58
000028  e5802018          STR      r2,[r0,#0x18]         ;59
;;;73         rGPDUP  = 0xffff;     // The pull up function is disabled GPD[15:0]
;;;74     
;;;75         //=== PORT E GROUP
;;;76         //Ports  : GPE15  GPE14  GPE13  GPE12   GPE11   GPE10   GPE9    GPE8     GPE7  GPE6  GPE5   GPE4  
;;;77         //Signal : IICSDA IICSCL SPICLK SPIMOSI SPIMISO SDDATA3 SDDATA2 SDDATA1 SDDATA0 SDCMD SDCLK I2SSDO 
;;;78         //Binary : 10     10,    10     10,     10      10,     10      10,      10    10,   10     10,       
;;;79         //----------------------------------------------------------------------------------------
;;;80         //Ports  :  GPE3   GPE2  GPE1    GPE0    
;;;81         //Signal : I2SSDI CDCLK I2SSCLK I2SLRCK     
;;;82         //Binary :  10     10,    10      10 
;;;83         rGPECON = 0xa6aaaaaa;       
00002c  e0843d01          ADD      r3,r4,r1,LSL #26
000030  e580c020          STR      r12,[r0,#0x20]        ;65
000034  e5801028          STR      r1,[r0,#0x28]         ;66
;;;84         rGPEUP  = 0xffff;     // The pull up function is disabled GPE[15:0]
;;;85     	rGPEDAT = 0x2000;
000038  e3a0ca02          MOV      r12,#0x2000
00003c  e5804030          STR      r4,[r0,#0x30]         ;72
;;;86         //=== PORT F GROUP
;;;87         //Ports  : GPF7   GPF6   GPF5   GPF4   GPF3    GPF2      GPF1    GPF0
;;;88         //Signal : LED_4  LED_3  LED_2  LED_1  PS2_INT CPLD_INT1 KEY_INT BUT_INT1
;;;89         //Setting: Output Output Output Output EINT3   EINT2     EINT1   EINT0
;;;90         //Binary : 01     01,    01     01,    10      10,       10      10
;;;91         rGPFCON = 0x55aa;
000040  e59f46f8          LDR      r4,|L1.1856|
000044  e5801038          STR      r1,[r0,#0x38]         ;73
;;;92         rGPFUP  = 0xff;     // The pull up function is disabled GPF[7:0]
000048  e3a050ff          MOV      r5,#0xff
00004c  e5803040          STR      r3,[r0,#0x40]         ;83
;;;93     
;;;94         //=== PORT G GROUP
;;;95         //Ports  : GPG15 GPG14 GPG13 GPG12 GPG11  GPG10  GPG9      GPG8      GPG7    GPG6    
;;;96         //Signal : nYPON YMON  nXPON XMON  GPG11  SD_CD  CPLD_INT3 CPLD_INT2 SPICLK1 SPIMOSI
;;;97         //Setting: nYPON YMON  nXPON XMON  Output Iutput EINT17    EINT17    SPICLK1 SPIMOSI1
;;;98         //Binary : 11    11,   11    11,   01     00,    10        10,       11      11
;;;99         //---------------------------------------------------------------------------------------
;;;100        //Ports  : GPG5     GPG4      GPG3     GPG2 GPG1    GPG0    
;;;101        //Signal : SPIMISO1 LCD_PWREN BUT_INT2 nSS0 NET_INT GPG0
;;;102        //Setting: SPIMISO1 LCD_PWRDN EINT11   nSS0 EINT9   Output
;;;103        //Binary : 11       11,       10       11,  10      *01
;;;104        rGPGCON = 0xff4af7b9;
000050  e59f36ec          LDR      r3,|L1.1860|
000054  e5801048          STR      r1,[r0,#0x48]         ;84
000058  e580c044          STR      r12,[r0,#0x44]        ;85
00005c  e5804050          STR      r4,[r0,#0x50]         ;91
000060  e5805058          STR      r5,[r0,#0x58]         ;92
000064  e5803060          STR      r3,[r0,#0x60]
;;;105        rGPGUP  = 0xffff;    // The pull up function is disabled GPG[15:0]
000068  e5801068          STR      r1,[r0,#0x68]
;;;106    
;;;107        //rGPGCON = (rGPGCON & 0xfffffcff) | (1<<8);	// GPG4 [9:8] 11  -> LCD_PWREN Enable
;;;108        // Eable LCD 
;;;109        // rGPGDAT = (rGPGDAT & 0xffef) | (1<<4);
;;;110        // close LCD 
;;;111        rGPGDAT = rGPGDAT & 0xffcf;
00006c  e5901064          LDR      r1,[r0,#0x64]
000070  e59f36d0          LDR      r3,|L1.1864|
000074  e0011003          AND      r1,r1,r3
;;;112    
;;;113        //=== PORT H GROUP
;;;114        //Ports  : GPH10 GPH9     GPH8   GPH7  GPH6  GPH5 GPH4 GPH3 GPH2 GPH1  GPH0 
;;;115        //Signal : GPH10  CLKOUT0 SD_WP  CTS1  RTS1  RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
;;;116        //Setting: Output CLKOUT0 GPH8   nCTS1 nRTS1 RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
;;;117        //Binary : 10,    10      10,    11    11,   10   10,  10   10,  10    10
;;;118        rGPHCON = 0x2aaaaa;
000078  e59f36cc          LDR      r3,|L1.1868|
00007c  e5801064          STR      r1,[r0,#0x64]         ;111
000080  e5803070          STR      r3,[r0,#0x70]
;;;119        rGPHUP  = 0x7ff;    // The pull up function is disabled GPH[10:0]
000084  e5802078          STR      r2,[r0,#0x78]
;;;120        
;;;121    }
000088  e8bd0030          POP      {r4,r5}
00008c  e12fff1e          BX       lr
;;;122    
                          ENDP

                  uart_change_baud PROC
;;;131    *********************************************************************************************/
;;;132    void uart_change_baud(int nChannel, int nBaud)
000090  e92d4010          PUSH     {r4,lr}
;;;133    {
;;;134        if (nChannel == UART0)
;;;135    	    rUBRDIV0=( (int)(PCLK/16./nBaud + 0.5) -1 );
000094  e59f46b4          LDR      r4,|L1.1872|
000098  e3500000          CMP      r0,#0                 ;134
00009c  0a000010          BEQ      |L1.228|
;;;136        
;;;137        if (nChannel == UART1)
0000a0  e3500001          CMP      r0,#1
0000a4  0a00001b          BEQ      |L1.280|
;;;138    	    rUBRDIV1=( (int)(PCLK/16./nBaud) -1 );
;;;139    
;;;140        if (nChannel == UART2)
0000a8  e35000bb          CMP      r0,#0xbb
0000ac  1a00000a          BNE      |L1.220|
;;;141    	    rUBRDIV2=( (int)(PCLK/16./nBaud) -1 );
0000b0  e1a00001          MOV      r0,r1
0000b4  ebfffffe          BL       __aeabi_i2d
0000b8  e1a02000          MOV      r2,r0
0000bc  e1a03001          MOV      r3,r1
0000c0  e3a00000          MOV      r0,#0
0000c4  e1a01004          MOV      r1,r4
0000c8  ebfffffe          BL       __aeabi_ddiv
0000cc  ebfffffe          BL       __aeabi_d2iz
0000d0  e59f167c          LDR      r1,|L1.1876|
                  |L1.212|
0000d4  e2400001          SUB      r0,r0,#1
0000d8  e5810028          STR      r0,[r1,#0x28]
                  |L1.220|
;;;142    }
0000dc  e8bd4010          POP      {r4,lr}
0000e0  e12fff1e          BX       lr
                  |L1.228|
0000e4  e1a00001          MOV      r0,r1                 ;135
0000e8  ebfffffe          BL       __aeabi_i2d
0000ec  e1a02000          MOV      r2,r0                 ;135
0000f0  e1a03001          MOV      r3,r1                 ;135
0000f4  e3a00000          MOV      r0,#0                 ;135
0000f8  e1a01004          MOV      r1,r4                 ;135
0000fc  ebfffffe          BL       __aeabi_ddiv
000100  e59f3650          LDR      r3,|L1.1880|
000104  e3a02000          MOV      r2,#0                 ;135
000108  ebfffffe          BL       __aeabi_dadd
00010c  ebfffffe          BL       __aeabi_d2iz
000110  e3a01205          MOV      r1,#0x50000000        ;135
000114  eaffffee          B        |L1.212|
                  |L1.280|
000118  e1a00001          MOV      r0,r1                 ;138
00011c  ebfffffe          BL       __aeabi_i2d
000120  e1a02000          MOV      r2,r0                 ;138
000124  e1a03001          MOV      r3,r1                 ;138
000128  e3a00000          MOV      r0,#0                 ;138
00012c  e1a01004          MOV      r1,r4                 ;138
000130  ebfffffe          BL       __aeabi_ddiv
000134  ebfffffe          BL       __aeabi_d2iz
000138  e59f161c          LDR      r1,|L1.1884|
00013c  eaffffe4          B        |L1.212|
;;;143    
                          ENDP

                  delay PROC
;;;561    *********************************************************************************************/
;;;562    void delay(int nTime)
000140  e92d4070          PUSH     {r4-r6,lr}
;;;563    {
;;;564          // time=0: adjust the Delay function by WatchDog timer.
;;;565          // time>0: the number of loop time
;;;566          // resolution of time is 100us.
;;;567        int i,adjust=0;
;;;568        if(nTime==0)
;;;569        {
;;;570            nTime   = 200;
;;;571            adjust = 1;
;;;572            delayLoopCount = 400;
000144  e59f461c          LDR      r4,|L1.1896|
000148  e3500000          CMP      r0,#0                 ;568
;;;573    		//PCLK/1M,Watch-dog disable,1/64,interrupt disable,reset disable
;;;574            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3); 
00014c  e59f660c          LDR      r6,|L1.1888|
;;;575            rWTDAT = 0xffff;                             	//for first update
000150  e59f360c          LDR      r3,|L1.1892|
;;;576            rWTCNT = 0xffff;                             	//resolution=64us @any PCLK 
;;;577            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3)|(1<<5); 	//Watch-dog timer start
;;;578        }
;;;579        for(;nTime>0;nTime--)
;;;580            for(i=0;i<delayLoopCount;i++);
000154  15942000          LDRNE    r2,[r4,#0]  ; delayLoopCount
000158  e3a05000          MOV      r5,#0                 ;567
00015c  e3a01453          MOV      r1,#0x53000000        ;574
000160  0a000002          BEQ      |L1.368|
                  |L1.356|
000164  e3500000          CMP      r0,#0                 ;579
000168  ca000009          BGT      |L1.404|
00016c  ea00000e          B        |L1.428|
                  |L1.368|
000170  e3a02e19          MOV      r2,#0x190             ;572
000174  e59f05f0          LDR      r0,|L1.1900|
000178  e5842000          STR      r2,[r4,#0]            ;574  ; delayLoopCount
00017c  e5816000          STR      r6,[r1,#0]            ;574
000180  e5813004          STR      r3,[r1,#4]            ;575
000184  e5813008          STR      r3,[r1,#8]            ;576
000188  e5810000          STR      r0,[r1,#0]            ;577
00018c  e3a000c8          MOV      r0,#0xc8              ;570
000190  e3a05001          MOV      r5,#1                 ;571
                  |L1.404|
000194  e3a0c000          MOV      r12,#0
                  |L1.408|
000198  e15c0002          CMP      r12,r2
00019c  b28cc001          ADDLT    r12,r12,#1
0001a0  a2400001          SUBGE    r0,r0,#1
0001a4  bafffffb          BLT      |L1.408|
0001a8  eaffffed          B        |L1.356|
                  |L1.428|
;;;581        if(adjust==1)
0001ac  e3550001          CMP      r5,#1
0001b0  1a000006          BNE      |L1.464|
;;;582        {
;;;583            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3);   		//Watch-dog timer stop
0001b4  e5816000          STR      r6,[r1,#0]
;;;584            i = 0xffff - rWTCNT;                     		//1count->64us, 200*400 cycle runtime = 64*i us
0001b8  e5910008          LDR      r0,[r1,#8]
0001bc  e0430000          SUB      r0,r3,r0
;;;585            delayLoopCount = 8000000/(i*64);         		//200*400:64*i=1*x:100 -> x=80000*100/(64*i)   
0001c0  e1a01300          LSL      r1,r0,#6
0001c4  e59f05a4          LDR      r0,|L1.1904|
0001c8  ebfffffe          BL       __aeabi_idivmod
0001cc  e5840000          STR      r0,[r4,#0]  ; delayLoopCount
                  |L1.464|
;;;586        }
;;;587    }
0001d0  e8bd4070          POP      {r4-r6,lr}
0001d4  e12fff1e          BX       lr
;;;588    
                          ENDP

                  uart_init PROC
;;;153    *********************************************************************************************/
;;;154    void uart_init(int nMainClk, int nBaud, int nChannel)
0001d8  e92d41f0          PUSH     {r4-r8,lr}
;;;155    {
0001dc  e1b06000          MOVS     r6,r0
;;;156        int i;
;;;157        
;;;158        if(nMainClk == 0)
;;;159        nMainClk    = PCLK;
0001e0  059f658c          LDREQ    r6,|L1.1908|
;;;160    
;;;161        switch (nChannel)
;;;162        {
;;;163        	case UART0: 
;;;164    			rUFCON0 = 0x0;   //UART channel 0 FIFO control register, FIFO disable
;;;165    			rUMCON0 = 0x0;   //UART chaneel 0 MODEM control register, AFC disable
;;;166    			rULCON0 = 0x3;   //Line control register : Normal,No parity,1 stop,8 bits
;;;167    	// [10]       [9]     [8]     [7]          [6]      [5]        [4]         [3:2]          [1:0]
;;;168    	// Clock Sel, Tx Int, Rx Int, Rx Time Out, Rx err,  Loop-back, Send break, Transmit Mode, Receive Mode
;;;169    	// 0          1       0,      0            1        0          0,          01             01
;;;170    	// PCLK       Level   Pulse   Disable      Generate Normal     Normal      Interrupt or Polling
;;;171    			rUCON0  = 0x245;								// Control register
0001e4  e59f058c          LDR      r0,|L1.1912|
0001e8  e3520000          CMP      r2,#0                 ;161
0001ec  e3a04000          MOV      r4,#0                 ;161
0001f0  e3a03003          MOV      r3,#3                 ;166
0001f4  0a000004          BEQ      |L1.524|
0001f8  e3520001          CMP      r2,#1                 ;161
0001fc  0a000016          BEQ      |L1.604|
000200  e35200bb          CMP      r2,#0xbb              ;161
000204  0a000028          BEQ      |L1.684|
000208  ea000039          B        |L1.756|
                  |L1.524|
00020c  e3a05205          MOV      r5,#0x50000000        ;164
000210  e5854008          STR      r4,[r5,#8]            ;164
000214  e585400c          STR      r4,[r5,#0xc]          ;165
000218  e5853000          STR      r3,[r5,#0]            ;166
00021c  e5850004          STR      r0,[r5,#4]
;;;172    	//		rUBRDIV0=( (int)(nMainClk/16./nBaud) -1 );		// Baud rate divisior register 0
;;;173    			rUBRDIV0=( (int)(nMainClk/16./nBaud+0.5) -1 );	// Baud rate divisior register 0    
000220  e1a00001          MOV      r0,r1
000224  ebfffffe          BL       __aeabi_i2d
000228  e1a07000          MOV      r7,r0
00022c  e1a04001          MOV      r4,r1
000230  e1a00006          MOV      r0,r6
000234  ebfffffe          BL       __aeabi_i2d
000238  e3e02003          MVN      r2,#3
00023c  ebfffffe          BL       __ARM_scalbn
000240  e1a02007          MOV      r2,r7
000244  e1a03004          MOV      r3,r4
000248  ebfffffe          BL       __aeabi_ddiv
00024c  e59f3504          LDR      r3,|L1.1880|
000250  e3a02000          MOV      r2,#0
000254  ebfffffe          BL       __aeabi_dadd
;;;174    			break;
000258  ea00000f          B        |L1.668|
                  |L1.604|
;;;175    			
;;;176    		case UART1: 
;;;177    			rUFCON1 = 0x0;   //UART channel 1 FIFO control register, FIFO disable
00025c  e59f54f8          LDR      r5,|L1.1884|
000260  e5854008          STR      r4,[r5,#8]
;;;178    			rUMCON1 = 0x0;   //UART chaneel 1 MODEM control register, AFC disable
000264  e585400c          STR      r4,[r5,#0xc]
;;;179    			rULCON1 = 0x3;
000268  e5853000          STR      r3,[r5,#0]
;;;180    			rUCON1  = 0x245;
00026c  e5850004          STR      r0,[r5,#4]
;;;181    			rUBRDIV1=( (int)(nMainClk/16./nBaud) -1 );
000270  e1a00001          MOV      r0,r1
000274  ebfffffe          BL       __aeabi_i2d
000278  e1a07000          MOV      r7,r0
00027c  e1a04001          MOV      r4,r1
000280  e1a00006          MOV      r0,r6
000284  ebfffffe          BL       __aeabi_i2d
000288  e3e02003          MVN      r2,#3
00028c  ebfffffe          BL       __ARM_scalbn
000290  e1a02007          MOV      r2,r7
000294  e1a03004          MOV      r3,r4
000298  ebfffffe          BL       __aeabi_ddiv
                  |L1.668|
00029c  ebfffffe          BL       __aeabi_d2iz
0002a0  e2400001          SUB      r0,r0,#1              ;173
0002a4  e5850028          STR      r0,[r5,#0x28]         ;173
0002a8  ea000011          B        |L1.756|
                  |L1.684|
;;;182    			break;
;;;183    			
;;;184        	case UART2: 
;;;185    			rULCON2 = 0x3;
0002ac  e59f54a0          LDR      r5,|L1.1876|
0002b0  e5853000          STR      r3,[r5,#0]
;;;186    			rUCON2  = 0x245;
0002b4  e5850004          STR      r0,[r5,#4]
;;;187    			rUBRDIV2=( (int)(nMainClk/16./nBaud) -1 );    
0002b8  e1a00001          MOV      r0,r1
0002bc  ebfffffe          BL       __aeabi_i2d
0002c0  e1a08000          MOV      r8,r0
0002c4  e1a07001          MOV      r7,r1
0002c8  e1a00006          MOV      r0,r6
0002cc  ebfffffe          BL       __aeabi_i2d
0002d0  e3e02003          MVN      r2,#3
0002d4  ebfffffe          BL       __ARM_scalbn
0002d8  e1a02008          MOV      r2,r8
0002dc  e1a03007          MOV      r3,r7
0002e0  ebfffffe          BL       __aeabi_ddiv
0002e4  ebfffffe          BL       __aeabi_d2iz
0002e8  e2400001          SUB      r0,r0,#1
0002ec  e5850028          STR      r0,[r5,#0x28]
;;;188    			rUFCON2 = 0x0;   //UART channel 2 FIFO control register, FIFO disable
0002f0  e5854008          STR      r4,[r5,#8]
                  |L1.756|
;;;189    			break;
;;;190    			
;;;191    		default:
;;;192    			break;
;;;193    	}
;;;194    
;;;195        for(i=0;i<100;i++);
0002f4  e3a00002          MOV      r0,#2
                  |L1.760|
0002f8  e2800001          ADD      r0,r0,#1
0002fc  e3500064          CMP      r0,#0x64
000300  bafffffc          BLT      |L1.760|
;;;196        delay(400);
000304  e8bd41f0          POP      {r4-r8,lr}
000308  e3a00e19          MOV      r0,#0x190
00030c  eafffffe          B        delay
;;;197    }
;;;198    
                          ENDP

                  uart_select PROC
;;;206    *********************************************************************************************/
;;;207    void uart_select(int nChannel)
000310  e59f1450          LDR      r1,|L1.1896|
;;;208    {
;;;209        f_nWhichUart=nChannel;
000314  e5810004          STR      r0,[r1,#4]  ; f_nWhichUart
;;;210    }
000318  e12fff1e          BX       lr
;;;211    
                          ENDP

                  uart_txempty PROC
;;;219    *********************************************************************************************/
;;;220    void uart_txempty(int nChannel)
00031c  e3500000          CMP      r0,#0
;;;221    {
;;;222        if(nChannel==0)
;;;223            while(!(rUTRSTAT0 & 0x4)); //Wait until tx shifter is empty.
000320  03a00205          MOVEQ    r0,#0x50000000
000324  0a000009          BEQ      |L1.848|
;;;224              
;;;225        else if(nChannel==1)
000328  e3500001          CMP      r0,#1
;;;226            while(!(rUTRSTAT1 & 0x4)); //Wait until tx shifter is empty.
00032c  059f0428          LDREQ    r0,|L1.1884|
000330  0a00000a          BEQ      |L1.864|
;;;227            
;;;228        else if(nChannel==2)
000334  e3500002          CMP      r0,#2
;;;229            while(!(rUTRSTAT2 & 0x4)); //Wait until tx shifter is empty.
000338  059f0414          LDREQ    r0,|L1.1876|
;;;230    }
00033c  112fff1e          BXNE     lr
                  |L1.832|
000340  e5901010          LDR      r1,[r0,#0x10]         ;229
000344  e3110004          TST      r1,#4                 ;229
000348  0afffffc          BEQ      |L1.832|
00034c  e12fff1e          BX       lr
                  |L1.848|
000350  e5901010          LDR      r1,[r0,#0x10]         ;223
000354  e3110004          TST      r1,#4                 ;223
000358  0afffffc          BEQ      |L1.848|
00035c  e12fff1e          BX       lr
                  |L1.864|
000360  e5901010          LDR      r1,[r0,#0x10]         ;226
000364  e3110004          TST      r1,#4                 ;226
000368  0afffffc          BEQ      |L1.864|
00036c  e12fff1e          BX       lr
;;;231    
                          ENDP

                  uart_getch PROC
;;;239    *********************************************************************************************/
;;;240    char uart_getch(void)
000370  e59f03f0          LDR      r0,|L1.1896|
;;;241    {
;;;242        if(f_nWhichUart==0)
000374  e5900004          LDR      r0,[r0,#4]  ; f_nWhichUart
000378  e3500000          CMP      r0,#0
;;;243        {       
;;;244            while(!(rUTRSTAT0 & 0x1)); //Receive data ready
00037c  03a00205          MOVEQ    r0,#0x50000000
000380  0a00000b          BEQ      |L1.948|
;;;245            return RdURXH0();
;;;246        }
;;;247        else if(f_nWhichUart==1)
000384  e3500001          CMP      r0,#1
;;;248        {       
;;;249            while(!(rUTRSTAT1 & 0x1)); //Receive data ready
000388  059f03cc          LDREQ    r0,|L1.1884|
00038c  0a00000c          BEQ      |L1.964|
;;;250            return RdURXH1();
;;;251        }
;;;252        else if(f_nWhichUart==2)
000390  e3500002          CMP      r0,#2
;;;253        {
;;;254            while(!(rUTRSTAT2 & 0x1)); //Receive data ready
000394  059f03b8          LDREQ    r0,|L1.1876|
;;;255            return RdURXH2();
;;;256        }
;;;257    	return NULL;
000398  13a00000          MOVNE    r0,#0
;;;258    }
00039c  112fff1e          BXNE     lr
                  |L1.928|
0003a0  e5901010          LDR      r1,[r0,#0x10]         ;254
0003a4  e3110001          TST      r1,#1                 ;254
0003a8  0afffffc          BEQ      |L1.928|
                  |L1.940|
0003ac  e5d00024          LDRB     r0,[r0,#0x24]         ;255
0003b0  e12fff1e          BX       lr
                  |L1.948|
0003b4  e5901010          LDR      r1,[r0,#0x10]         ;244
0003b8  e3110001          TST      r1,#1                 ;244
0003bc  0afffffc          BEQ      |L1.948|
0003c0  eafffff9          B        |L1.940|
                  |L1.964|
0003c4  e5901010          LDR      r1,[r0,#0x10]         ;249
0003c8  e3110001          TST      r1,#1                 ;249
0003cc  0afffffc          BEQ      |L1.964|
0003d0  eafffff5          B        |L1.940|
;;;259    
                          ENDP

                  uart_getkey PROC
;;;267    *********************************************************************************************/
;;;268    char uart_getkey(void)
0003d4  e59f038c          LDR      r0,|L1.1896|
;;;269    {
;;;270        if(f_nWhichUart==0)
0003d8  e5900004          LDR      r0,[r0,#4]  ; f_nWhichUart
0003dc  e3500000          CMP      r0,#0
;;;271        {       
;;;272            if(rUTRSTAT0 & 0x1)    //Receive data ready
0003e0  03a00205          MOVEQ    r0,#0x50000000
0003e4  0a000005          BEQ      |L1.1024|
;;;273                return RdURXH0();
;;;274            else
;;;275                return 0;
;;;276        }
;;;277        else if(f_nWhichUart==1)
0003e8  e3500001          CMP      r0,#1
;;;278        {
;;;279            if(rUTRSTAT1 & 0x1)    //Receive data ready
0003ec  059f0368          LDREQ    r0,|L1.1884|
0003f0  0a000002          BEQ      |L1.1024|
;;;280                return RdURXH1();
;;;281            else
;;;282                return 0;
;;;283        }
;;;284        else if(f_nWhichUart==2)
0003f4  e3500002          CMP      r0,#2
;;;285        {       
;;;286            if(rUTRSTAT2 & 0x1)    //Receive data ready
0003f8  059f0354          LDREQ    r0,|L1.1876|
0003fc  1a000003          BNE      |L1.1040|
                  |L1.1024|
000400  e5901010          LDR      r1,[r0,#0x10]         ;272
000404  e3110001          TST      r1,#1                 ;272
;;;287                return RdURXH2();
000408  15d00024          LDRBNE   r0,[r0,#0x24]
;;;288            else
;;;289                return 0;
;;;290        }    
;;;291    	return NULL;
;;;292    }
00040c  112fff1e          BXNE     lr
                  |L1.1040|
000410  e3a00000          MOV      r0,#0                 ;291
000414  e12fff1e          BX       lr
;;;293    
                          ENDP

                  uart_sendbyte PROC
;;;403    *********************************************************************************************/
;;;404    void uart_sendbyte(int nData)
000418  e92d4070          PUSH     {r4-r6,lr}
;;;405    {
;;;406        if(f_nWhichUart==0)
00041c  e59f1344          LDR      r1,|L1.1896|
;;;407        {
;;;408            if(nData=='\n')
;;;409            {
;;;410                while(!(rUTRSTAT0 & 0x2));
;;;411                delay(10);					//because the slow response of hyper_terminal 
;;;412                WrUTXH0('\r');
;;;413            }
;;;414            while(!(rUTRSTAT0 & 0x2));		//Wait until THR is empty.
;;;415            delay(10);
;;;416            WrUTXH0(nData);
000420  e20050ff          AND      r5,r0,#0xff
000424  e5911004          LDR      r1,[r1,#4]            ;406  ; f_nWhichUart
000428  e3a0600d          MOV      r6,#0xd               ;412
00042c  e3510000          CMP      r1,#0                 ;406
000430  0a000007          BEQ      |L1.1108|
;;;417        }
;;;418        else if(f_nWhichUart==1)
000434  e3510001          CMP      r1,#1
000438  0a000016          BEQ      |L1.1176|
;;;419        {
;;;420            if(nData=='\n')
;;;421            {
;;;422                while(!(rUTRSTAT1 & 0x2));
;;;423                delay(10);					//because the slow response of hyper_terminal 
;;;424                rUTXH1 = '\r';
;;;425            }
;;;426            while(!(rUTRSTAT1 & 0x2));		//Wait until THR is empty.
;;;427            delay(10);
;;;428            rUTXH1 = nData;
;;;429        }   
;;;430        else if(f_nWhichUart==2)
00043c  e3510002          CMP      r1,#2
000440  1a000012          BNE      |L1.1168|
;;;431        {
;;;432            if(nData=='\n')
;;;433            {
;;;434                while(!(rUTRSTAT2 & 0x2));
000444  e59f4308          LDR      r4,|L1.1876|
000448  e350000a          CMP      r0,#0xa               ;432
00044c  1a000024          BNE      |L1.1252|
000450  ea00001d          B        |L1.1228|
                  |L1.1108|
000454  e350000a          CMP      r0,#0xa               ;408
000458  e3a04205          MOV      r4,#0x50000000        ;410
00045c  1a000005          BNE      |L1.1144|
                  |L1.1120|
000460  e5940010          LDR      r0,[r4,#0x10]         ;410
000464  e3100002          TST      r0,#2                 ;410
000468  0afffffc          BEQ      |L1.1120|
00046c  e3a0000a          MOV      r0,#0xa               ;411
000470  ebfffffe          BL       delay
000474  e5c46020          STRB     r6,[r4,#0x20]         ;412
                  |L1.1144|
000478  e5940010          LDR      r0,[r4,#0x10]         ;414
00047c  e3100002          TST      r0,#2                 ;414
000480  0afffffc          BEQ      |L1.1144|
                  |L1.1156|
000484  e3a0000a          MOV      r0,#0xa               ;415
000488  ebfffffe          BL       delay
00048c  e5c45020          STRB     r5,[r4,#0x20]         ;416
                  |L1.1168|
;;;435                delay(10);					//because the slow response of hyper_terminal 
;;;436                rUTXH2 = '\r';
;;;437            }
;;;438            while(!(rUTRSTAT2 & 0x2));		//Wait until THR is empty.
;;;439            delay(10);
;;;440            rUTXH2 = nData;
;;;441        }       
;;;442    }               
000490  e8bd4070          POP      {r4-r6,lr}
000494  e12fff1e          BX       lr
                  |L1.1176|
000498  e59f42bc          LDR      r4,|L1.1884|
00049c  e350000a          CMP      r0,#0xa               ;420
0004a0  1a000005          BNE      |L1.1212|
                  |L1.1188|
0004a4  e5940010          LDR      r0,[r4,#0x10]         ;422
0004a8  e3100002          TST      r0,#2                 ;422
0004ac  0afffffc          BEQ      |L1.1188|
0004b0  e3a0000a          MOV      r0,#0xa               ;423
0004b4  ebfffffe          BL       delay
0004b8  e5c46020          STRB     r6,[r4,#0x20]         ;424
                  |L1.1212|
0004bc  e5940010          LDR      r0,[r4,#0x10]         ;426
0004c0  e3100002          TST      r0,#2                 ;426
0004c4  0afffffc          BEQ      |L1.1212|
0004c8  eaffffed          B        |L1.1156|
                  |L1.1228|
0004cc  e5940010          LDR      r0,[r4,#0x10]         ;434
0004d0  e3100002          TST      r0,#2                 ;434
0004d4  0afffffc          BEQ      |L1.1228|
0004d8  e3a0000a          MOV      r0,#0xa               ;435
0004dc  ebfffffe          BL       delay
0004e0  e5c46020          STRB     r6,[r4,#0x20]         ;436
                  |L1.1252|
0004e4  e5940010          LDR      r0,[r4,#0x10]         ;438
0004e8  e3100002          TST      r0,#2                 ;438
0004ec  0afffffc          BEQ      |L1.1252|
0004f0  eaffffe3          B        |L1.1156|
;;;443    
                          ENDP

                  uart_sendstring PROC
;;;451    *********************************************************************************************/
;;;452    void uart_sendstring(char *pString)
0004f4  e92d4010          PUSH     {r4,lr}
;;;453    {
0004f8  e1a04000          MOV      r4,r0
;;;454        while(*pString)
;;;455            uart_sendbyte(*pString++);
0004fc  ea000001          B        |L1.1288|
                  |L1.1280|
000500  e2844001          ADD      r4,r4,#1              ;454
000504  ebfffffe          BL       uart_sendbyte
                  |L1.1288|
000508  e5d40000          LDRB     r0,[r4,#0]            ;454
00050c  e3500000          CMP      r0,#0                 ;454
000510  1afffffa          BNE      |L1.1280|
;;;456    }
000514  e8bd4010          POP      {r4,lr}
000518  e12fff1e          BX       lr
;;;457    
                          ENDP

                  uart_printf PROC
;;;465    *********************************************************************************************/
;;;466    void uart_printf(char *fmt,...)
00051c  e92d000f          PUSH     {r0-r3}
;;;467    {
000520  e52de004          PUSH     {lr}
000524  e24ddf41          SUB      sp,sp,#0x104
;;;468        va_list ap;
;;;469        char pString[256];
;;;470    
;;;471        va_start(ap,fmt);
;;;472        vsprintf(pString,fmt,ap);
000528  e59d1108          LDR      r1,[sp,#0x108]
00052c  e28d2f43          ADD      r2,sp,#0x10c          ;471
000530  e1a0000d          MOV      r0,sp
000534  ebfffffe          BL       __c89vsprintf
;;;473        uart_sendstring(pString);
000538  e1a0000d          MOV      r0,sp
00053c  ebfffffe          BL       uart_sendstring
;;;474        va_end(ap);
;;;475    }
000540  e28ddf41          ADD      sp,sp,#0x104
000544  e49de014          LDR      lr,[sp],#0x14
000548  e12fff1e          BX       lr
;;;476    
                          ENDP

                  uart_getstring PROC
;;;301    *********************************************************************************************/
;;;302    void uart_getstring(char *pString)
00054c  e92d4070          PUSH     {r4-r6,lr}
;;;303    {
000550  e1a04000          MOV      r4,r0
;;;304        char *string2 = pString;
000554  e1a05000          MOV      r5,r0
000558  ea000003          B        |L1.1388|
                  |L1.1372|
;;;305        char c;
;;;306        while((c = uart_getch())!='\r')
;;;307        {
;;;308            if(c=='\b')
00055c  e3500008          CMP      r0,#8
000560  0a000009          BEQ      |L1.1420|
;;;309            {
;;;310                if( (int)string2 < (int)pString )
;;;311                {
;;;312                    uart_printf("\b \b");
;;;313                    pString--;
;;;314                }
;;;315            }
;;;316            else 
;;;317            {
;;;318                *pString++ = c;
000564  e4c40001          STRB     r0,[r4],#1
;;;319                uart_sendbyte(c);
000568  ebfffffe          BL       uart_sendbyte
                  |L1.1388|
00056c  ebfffffe          BL       uart_getch
000570  e350000d          CMP      r0,#0xd               ;306
000574  1afffff8          BNE      |L1.1372|
;;;320            }
;;;321        }
;;;322        *pString='\0';
000578  e3a00000          MOV      r0,#0
00057c  e5c40000          STRB     r0,[r4,#0]
;;;323        uart_sendbyte('\n');
000580  e8bd4070          POP      {r4-r6,lr}
000584  e3a0000a          MOV      r0,#0xa
000588  eafffffe          B        uart_sendbyte
                  |L1.1420|
00058c  e1550004          CMP      r5,r4                 ;310
000590  aafffff5          BGE      |L1.1388|
000594  e28f0e1e          ADR      r0,|L1.1916|
000598  ebfffffe          BL       uart_printf
00059c  e2444001          SUB      r4,r4,#1              ;312
0005a0  eafffff1          B        |L1.1388|
;;;324    }
;;;325    
                          ENDP

                  uart_getintnum PROC
;;;335    *********************************************************************************************/
;;;336    int uart_getintnum(void)
0005a4  e92d41f0          PUSH     {r4-r8,lr}
;;;337    {
0005a8  e24dd020          SUB      sp,sp,#0x20
;;;338        char str[30];
;;;339        char *pString = str;
0005ac  e1a0500d          MOV      r5,sp
;;;340        int base     = 10;
;;;341        int minus    = 0;
0005b0  e3a08000          MOV      r8,#0
0005b4  e3a0600a          MOV      r6,#0xa               ;340
;;;342        int nResult   = 0;
0005b8  e1a04008          MOV      r4,r8
;;;343        int lastIndex;    
;;;344        int i;
;;;345        
;;;346        uart_getstring(pString);
0005bc  e1a00005          MOV      r0,r5
0005c0  ebfffffe          BL       uart_getstring
;;;347        
;;;348        if(pString[0]=='-')
0005c4  e5dd0000          LDRB     r0,[sp,#0]
0005c8  e350002d          CMP      r0,#0x2d
;;;349        {
;;;350            minus = 1;
0005cc  02855001          ADDEQ    r5,r5,#1
;;;351            pString++;
;;;352        }
;;;353        
;;;354        if(pString[0]=='0' && (pString[1]=='x' || pString[1]=='X'))
0005d0  e5d50000          LDRB     r0,[r5,#0]
0005d4  03a08001          MOVEQ    r8,#1                 ;350
0005d8  e3500030          CMP      r0,#0x30
0005dc  0a00000f          BEQ      |L1.1568|
                  |L1.1504|
;;;355        {
;;;356            base    = 16;
;;;357            pString += 2;
;;;358        }
;;;359        
;;;360        lastIndex = strlen(pString) - 1;
0005e0  e1a00005          MOV      r0,r5
0005e4  ebfffffe          BL       strlen
0005e8  e2507001          SUBS     r7,r0,#1
;;;361        
;;;362        if(lastIndex<0)
;;;363            return -1;
0005ec  43e00000          MVNMI    r0,#0
0005f0  4a000014          BMI      |L1.1608|
;;;364        
;;;365        if(pString[lastIndex]=='h' || pString[lastIndex]=='H' )
0005f4  e7d50007          LDRB     r0,[r5,r7]
0005f8  e3500068          CMP      r0,#0x68
0005fc  13500048          CMPNE    r0,#0x48
;;;366        {
;;;367            base = 16;
;;;368            pString[lastIndex] = 0;
000600  03a00000          MOVEQ    r0,#0
000604  07c50007          STRBEQ   r0,[r5,r7]
000608  02477001          SUBEQ    r7,r7,#1
00060c  0a000001          BEQ      |L1.1560|
;;;369            lastIndex--;
;;;370        }
;;;371    
;;;372        if(base==10)
000610  e356000a          CMP      r6,#0xa
000614  0a000007          BEQ      |L1.1592|
                  |L1.1560|
;;;373        {
;;;374            nResult = atoi(pString);
;;;375            nResult = minus ? (-1*nResult):nResult;
;;;376        }
;;;377        else
;;;378        {
;;;379            for(i=0;i<=lastIndex;i++)
000618  e3a06000          MOV      r6,#0
00061c  ea00001a          B        |L1.1676|
                  |L1.1568|
000620  e5d50001          LDRB     r0,[r5,#1]            ;354
000624  e3500078          CMP      r0,#0x78              ;354
000628  13500058          CMPNE    r0,#0x58              ;354
00062c  03a06010          MOVEQ    r6,#0x10              ;356
000630  02855002          ADDEQ    r5,r5,#2              ;356
000634  eaffffe9          B        |L1.1504|
                  |L1.1592|
000638  e1a00005          MOV      r0,r5                 ;374
00063c  ebfffffe          BL       atoi
000640  e3580000          CMP      r8,#0                 ;375
000644  12600000          RSBNE    r0,r0,#0              ;375
                  |L1.1608|
000648  e28dd020          ADD      sp,sp,#0x20           ;375
00064c  e8bd41f0          POP      {r4-r8,lr}            ;375
;;;380            {
;;;381                if(isalpha(pString[i]))
;;;382                {
;;;383                    if(isupper(pString[i]))
;;;384                        nResult = (nResult<<4) + pString[i] - 'A' + 10;
;;;385                    else
;;;386                        nResult = (nResult<<4) + pString[i] - 'a' + 10;
;;;387                }
;;;388                else
;;;389                    nResult = (nResult<<4) + pString[i] - '0';
;;;390            }
;;;391            nResult = minus ? (-1*nResult):nResult;
;;;392        }
;;;393        return nResult;
;;;394    }
000650  e12fff1e          BX       lr
                  |L1.1620|
000654  ebfffffe          BL       __rt_ctype_table
000658  e1a01000          MOV      r1,r0                 ;381
00065c  e7d50006          LDRB     r0,[r5,r6]            ;381
000660  e5911000          LDR      r1,[r1,#0]            ;381
000664  e7d11000          LDRB     r1,[r1,r0]            ;381
000668  e3110098          TST      r1,#0x98              ;381
00066c  00800204          ADDEQ    r0,r0,r4,LSL #4       ;389
000670  02404030          SUBEQ    r4,r0,#0x30           ;389
000674  0a000003          BEQ      |L1.1672|
000678  e3110010          TST      r1,#0x10              ;383
00067c  e0800204          ADD      r0,r0,r4,LSL #4       ;386
000680  12404037          SUBNE    r4,r0,#0x37           ;384
000684  02404057          SUBEQ    r4,r0,#0x57           ;386
                  |L1.1672|
000688  e2866001          ADD      r6,r6,#1              ;389
                  |L1.1676|
00068c  e1560007          CMP      r6,r7                 ;379
000690  daffffef          BLE      |L1.1620|
000694  e3580000          CMP      r8,#0                 ;391
000698  12640000          RSBNE    r0,r4,#0              ;391
00069c  01a00004          MOVEQ    r0,r4                 ;391
0006a0  eaffffe8          B        |L1.1608|
;;;395    
                          ENDP

                  timer_start PROC
;;;484    *********************************************************************************************/
;;;485    void timer_start(int divider)  
0006a4  e3a03c31          MOV      r3,#0x3100
;;;486    {
;;;487        rWTCON = ((PCLK/1000000-1)<<8)|(divider<<3); //Watch-dog timer control register
;;;488        rWTDAT = 0xffff;							 //Watch-dog timer data register
0006a8  e59f20b4          LDR      r2,|L1.1892|
0006ac  e3a01453          MOV      r1,#0x53000000        ;487
0006b0  e1830180          ORR      r0,r3,r0,LSL #3       ;487
0006b4  e5810000          STR      r0,[r1,#0]            ;487
0006b8  e5812004          STR      r2,[r1,#4]
;;;489        rWTCNT = 0xffff;							 //Watch-dog count register
0006bc  e5812008          STR      r2,[r1,#8]
;;;490    
;;;491        rWTCON = rWTCON | (1<<5) | ~(1<<2);  		 //May 06, 2002 SOP
0006c0  e5910000          LDR      r0,[r1,#0]
0006c4  e3e02004          MVN      r2,#4
0006c8  e1800002          ORR      r0,r0,r2
0006cc  e5810000          STR      r0,[r1,#0]
;;;492    }
0006d0  e12fff1e          BX       lr
;;;493    
                          ENDP

                  timer_stop PROC
;;;501    *********************************************************************************************/
;;;502    int timer_stop(void)
0006d4  e3a00453          MOV      r0,#0x53000000
;;;503    {
;;;504        rWTCON = ((PCLK/1000000-1)<<8);
0006d8  e3a01c31          MOV      r1,#0x3100
0006dc  e5801000          STR      r1,[r0,#0]
;;;505        return (0xffff - rWTCNT);
0006e0  e59f107c          LDR      r1,|L1.1892|
0006e4  e5900008          LDR      r0,[r0,#8]
0006e8  e0410000          SUB      r0,r1,r0
;;;506    }
0006ec  e12fff1e          BX       lr
;;;507    
                          ENDP

                  change_value_MPLL PROC
;;;515    *********************************************************************************************/
;;;516    void change_value_MPLL(int nMdiv,int nPdiv,int nSdiv)
0006f0  e1a03600          LSL      r3,r0,#12
;;;517    {
;;;518        rMPLLCON = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
0006f4  e1831201          ORR      r1,r3,r1,LSL #4
0006f8  e3a00313          MOV      r0,#0x4c000000
0006fc  e1811002          ORR      r1,r1,r2
000700  e5801004          STR      r1,[r0,#4]
;;;519    }
000704  e12fff1e          BX       lr
;;;520    
                          ENDP

                  change_clock_divider PROC
;;;528    *********************************************************************************************/
;;;529    void change_clock_divider(int nHdiv,int nPdiv)
000708  e3a02313          MOV      r2,#0x4c000000
;;;530    {
;;;531         // nHdiv,nPdiv FCLK:HCLK:PCLK
;;;532         //     0,0         1:1:1 
;;;533         //     0,1         1:1:2 
;;;534         //     1,0         1:2:2
;;;535         //     1,1         1:2:4
;;;536        rCLKDIVN = (nHdiv<<1) | nPdiv;    
00070c  e1810080          ORR      r0,r1,r0,LSL #1
000710  e5820014          STR      r0,[r2,#0x14]
;;;537        
;;;538    }
000714  e12fff1e          BX       lr
;;;539    
                          ENDP

                  ChangeUPllValue PROC
;;;547    *********************************************************************************************/
;;;548    void ChangeUPllValue(int nMdiv,int nPdiv,int nSdiv)
000718  e1a03600          LSL      r3,r0,#12
;;;549    {
;;;550        rUPLLCON = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
00071c  e1831201          ORR      r1,r3,r1,LSL #4
000720  e3a00313          MOV      r0,#0x4c000000
000724  e1811002          ORR      r1,r1,r2
000728  e5801008          STR      r1,[r0,#8]
;;;551    }
00072c  e12fff1e          BX       lr
                  |L1.1840|
                          DCD      0x000007ff
                  |L1.1844|
                          DCD      0x005fbfff
                  |L1.1848|
                          DCD      0x00155559
                  |L1.1852|
                          DCD      0xaaaa55aa
                  |L1.1856|
                          DCD      0x000055aa
                  |L1.1860|
                          DCD      0xff4af7b9
                  |L1.1864|
                          DCD      0x0000ffcf
                  |L1.1868|
                          DCD      0x002aaaaa
                  |L1.1872|
                          DCD      0x41482cf7
                  |L1.1876|
                          DCD      0x50008000
                  |L1.1880|
                          DCD      0x3fe00000
                  |L1.1884|
                          DCD      0x50004000
                  |L1.1888|
                          DCD      0x00003110
                  |L1.1892|
                          DCD      0x0000ffff
                  |L1.1896|
                          DCD      ||.data||
                  |L1.1900|
                          DCD      0x00003130
                  |L1.1904|
                          DCD      0x007a1200
                  |L1.1908|
                          DCD      0x03059ee0
                  |L1.1912|
                          DCD      0x00000245
                  |L1.1916|
00077c  08200800          DCB      "\b \b",0
                          ENDP

                  EnableMMU PROC
;;;596    *********************************************************************************************/
;;;597    void EnableMMU()
000780  ee110f10          MRC      p15,#0x0,r0,c1,c0,#0
;;;598    {
;;;599    	unsigned int ctl;
;;;600    
;;;601    	ctl = ARM_ReadControl();
;;;602    	ctl |= (1 << 0);
000784  e3800001          ORR      r0,r0,#1
000788  ee010f10          MCR      p15,#0x0,r0,c1,c0,#0
;;;603    	ARM_WriteControl(ctl);
;;;604    }
00078c  e12fff1e          BX       lr
;;;605    
                          ENDP

                  InitMMU PROC
;;;613    *********************************************************************************************/
;;;614    void InitMMU(unsigned int *pTranslationTable)
000790  e1a01720          LSR      r1,r0,#14
000794  e1a01701          LSL      r1,r1,#14
000798  ee021f10          MCR      p15,#0x0,r1,c2,c0,#0
;;;615    {
;;;616    	int i;
;;;617    	// Program the TTB
;;;618    	ARM_WriteTTB((unsigned int) pTranslationTable);
;;;619    	// Program the domain access register
;;;620    	ARM_WriteDomain(0xC0000000); 		// domain 15: access are not checked
00079c  e3a01103          MOV      r1,#0xc0000000
0007a0  ee031f10          MCR      p15,#0x0,r1,c3,c0,#0
0007a4  e3a02000          MOV      r2,#0
;;;621    
;;;622    	// Reset table entries
;;;623    	for (i = 0; i < 0x200; ++i)
0007a8  e1a01002          MOV      r1,r2
                  |L1.1964|
;;;624    		pTranslationTable[i] = 0;
0007ac  e7802101          STR      r2,[r0,r1,LSL #2]
0007b0  e2811001          ADD      r1,r1,#1
0007b4  e3510c02          CMP      r1,#0x200             ;623
0007b8  bafffffb          BLT      |L1.1964|
;;;625    
;;;626    	// Program level 1 page table entry
;;;627    	pTranslationTable[0x0] =
0007bc  e59f1040          LDR      r1,|L1.2052|
;;;628    		(0x300 << 20) |  				// Physical Address
;;;629    		(1 << 10) |      				// Access in supervisor mode
;;;630    		(15 << 5) |      				// Domain
;;;631    		1 << 4 |
;;;632    		0x2;             				// Set as 1 Mbyte section
;;;633    	pTranslationTable[0x1] =
0007c0  e2812601          ADD      r2,r1,#0x100000
;;;634    		(0x301 << 20) |  				// Physical Address
;;;635    		(1 << 10) |      				// Access in supervisor mode
;;;636    		(15 << 5) |      				// Domain
;;;637    		1 << 4 |
;;;638    		0x2;             				// Set as 1 Mbyte section
;;;639    	pTranslationTable[0x2] =
0007c4  e2813602          ADD      r3,r1,#0x200000
;;;640    		(0x302 << 20) |  				// Physical Address
;;;641    		(1 << 10) |      				// Access in supervisor mode
;;;642    		(15 << 5) |      				// Domain
;;;643    		1 << 4 |
;;;644    		0x2;             				// Set as 1 Mbyte section
;;;645    	pTranslationTable[0x3] =
0007c8  e281c603          ADD      r12,r1,#0x300000
0007cc  e880100e          STM      r0,{r1-r3,r12}
;;;646    		(0x303 << 20) |  				// Physical Address
;;;647    		(1 << 10) |      				// Access in supervisor mode
;;;648    		(15 << 5) |      				// Domain
;;;649    		1 << 4 |
;;;650    		0x2;             				// Set as 1 Mbyte section
;;;651    
;;;652    	for(i = 0x200; i < 0xFFF; ++i)
0007d0  e59f3030          LDR      r3,|L1.2056|
0007d4  e3a01c02          MOV      r1,#0x200
;;;653    		pTranslationTable[i] = 
0007d8  e1c22462          BIC      r2,r2,r2,ROR #8
                  |L1.2012|
0007dc  e182ca01          ORR      r12,r2,r1,LSL #20
0007e0  e780c101          STR      r12,[r0,r1,LSL #2]
0007e4  e2811001          ADD      r1,r1,#1
0007e8  e1510003          CMP      r1,r3                 ;652
0007ec  ae110f10          MRCGE    p15,#0x0,r0,c1,c0,#0  ;652
0007f0  a3800001          ORRGE    r0,r0,#1              ;652
0007f4  ae010f10          MCRGE    p15,#0x0,r0,c1,c0,#0  ;652
0007f8  bafffff7          BLT      |L1.2012|
;;;654    			(i << 20) |  				// Physical Address
;;;655    			(1 << 10) |      			// Access in supervisor mode
;;;656    			(15 << 5) |      			// Domain
;;;657    			1 << 4 |
;;;658    			0x2;             			// Set as 1 Mbyte section
;;;659    
;;;660    	EnableMMU();		 				// Enable the MMU
;;;661    }
0007fc  e12fff1e          BX       lr
;;;662    
                          ENDP

                  __gccmain PROC
;;;670    *********************************************************************************************/
;;;671    void __gccmain(void)
000800  e12fff1e          BX       lr
;;;672    {
;;;673    }
                          ENDP

                  |L1.2052|
                          DCD      0x300005f2
                  |L1.2056|
                          DCD      0x00000fff

                          AREA ||.data||, DATA, ALIGN=2

                  delayLoopCount
                          DCD      0x000007ec
                  f_nWhichUart
                          DCD      0x00000000

                          AREA ||area_number.5||, DATA, ALIGN=0

                          EXPORTAS ||area_number.5||, ||.data||
                  ||Image$$RW_ZI$$ZI$$Limit||
000000  00                DCB      0x00
